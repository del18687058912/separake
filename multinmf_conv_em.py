# Autogenerated with SMOP
from smop.core import *
# multi_nmf_toolbox/multinmf_conv_em.m

import numpy as np


@function
def multinmf_conv_em(X=None, W0=None, H0=None, A0=None, Sigma_b0=None, source_NMF_ind=None, iter_num=None, SimAnneal_flag=None, Sigma_b_Upd_flag=None, *args, **kwargs):
    varargin = multinmf_conv_em.varargin
    nargin = multinmf_conv_em.nargin

# [W,H,A,Sigma_b,S,log_like_arr] = ...
#    multinmf_conv_em(X, W0, H0, A0, Sigma_b0, source_NMF_ind, iter_num, SimAnneal_flag, Sigma_b_Upd_flag);

# EM algorithm for multichannel NMF decomposition in convolutive mixture (stereo)

# input
# -----

# X                 : truncated STFT of multichannal mixture [F x N x 2]
# W0                : initial matrix of bases [F x K]
# H0                : initial matrix of contributions [K x N]
# A0                : initial (complex-valued) convolutive mixing matrices [F x 2 x J]
# Sigma_b0          : initial additive noise covariances [F x 1] vector
# source_NMF_ind    : source indices in the NMF decomposition
# iter_num          : (opt) number of EM iterations (def = 100)
# SimAnneal_flag    : (opt) simulated annealing flag (def = 1)
#                         0 = no annealing
#                         1 = annealing
#                         2 = annealing with noise injection
# Sigma_b_Upd_flag  : (opt) Sigma_b update flag (def = 0)

# output
# ------

# W                 : estimated matrix of bases [F x K]
# H                 : estimated matrix of contributions [K x N]
# A                 : estimated (complex-valued) convolutive mixing matrices [F x 2 x J]
# Sigma_b           : final additive noise covariances [F x 1] vector
# S                 : estimated truncated STFTs of sources [F x N x J]
# log_like_arr      : array of log-likelihoods

###########################################################################
# Copyright 2017 Robin Scheibler

# Adapted from Matlab code by Alexey Ozerov
# Copyright 2010 Alexey Ozerov
# (alexey.ozerov -at- irisa.fr)

# This software is distributed under the terms of the GNU Public License
# version 3 (http://www.gnu.org/licenses/gpl.txt)

# If you use this code please cite this paper

# A. Ozerov and C. Fevotte,
# "Multichannel nonnegative matrix factorization in convolutive mixtures for audio source separation,"
# IEEE Trans. on Audio, Speech and Lang. Proc. special issue on Signal Models and Representations
# of Musical and Environmental Sounds, vol. 18, no. 3, pp. 550-563, March 2010.
# Available: http://www.irisa.fr/metiss/ozerov/Publications/OzerovFevotte_IEEE_TASLP10.pdf
###########################################################################

# some constants
final_ann_noise_var = 3e-11

if nargin < 7 or isempty(iter_num):
    iter_num = 100

if nargin < 8 or isempty(SimAnneal_flag):
    SimAnneal_flag = 1

if nargin < 9 or isempty(Sigma_b_Upd_flag):
    Sigma_b_Upd_flag = 0

F, N, I = size(X, nargout=3)
K = size(W0, 2)
J = length(source_NMF_ind)
if I != 2:
    raise ValueError('Multi_NMF_EM_conv: number of channels must be 2')

if SimAnneal_flag and Sigma_b_Upd_flag:
    raise ValueError('The flags SimAnneal_flag and Sigma_b_Upd_flag cannot be on simultaneously')

Xb = copy(X)
W = copy(W0)
H = copy(H0)
A = copy(A0)
Sigma_b = copy(Sigma_b0)
O = ones(1, N)
sigma_ss = zeros(F, N, J)
Sigma_x = zeros(F, N, 2, 2)
Inv_Sigma_x = zeros(F, N, 2, 2)
Gs = zeros(F, N, J, 2)
Gs_x = zeros(F, N, J)
bar_Rxs = zeros(F, 2, J)
bar_Rss = zeros(F, J, J)
bar_Rxx = zeros(F, 2, 2)
bar_A = zeros(F, 2, K)
Vc = zeros(F, N, K)
log_like_arr = zeros(1, iter_num)
# initialize simulated annealing variances (if necessary)
if SimAnneal_flag:
    Sigma_b_anneal = zeros(F, iter_num)
    for iter in arange(1, iter_num).reshape(-1):
        Sigma_b_anneal[:, iter] = ((dot(sqrt(Sigma_b0), (iter_num - iter)) + dot(
            dot(ones(F, 1), sqrt(final_ann_noise_var)), iter)) / iter_num) ** 2

# MAIN LOOP
for iter in arange(1, iter_num).reshape(-1):
    fprintf('EM iteration %d of %d\\n', iter, iter_num)
    W_prev = copy(W)
    H_prev = copy(H)
    A_prev = copy(A)
    Sigma_b_prev = copy(Sigma_b)
    fprintf('   E-step\\n')
    sigma_ss = dot(sigma_ss, 0)
    for j in arange(1, J).reshape(-1):
        for k in arange(1, length(source_NMF_ind[j])).reshape(-1):
            sigma_ss[:, :, j] = sigma_ss[:, :, j] + \
                dot(W[:, source_NMF_ind[j](k)], H[source_NMF_ind[j](k), :])
    if SimAnneal_flag:
        Sigma_b = Sigma_b_anneal[:, iter]
        if SimAnneal_flag == 2:
            Noise = randn(F, N, 2) + dot(sqrt(- 1), randn(F, N, 2))
            Noise[:, :, 1] = multiply(
                Noise[:, :, 1], (dot(sqrt(Sigma_b / 2), ones(1, N))))
            Noise[:, :, 2] = multiply(
                Noise[:, :, 2], (dot(sqrt(Sigma_b / 2), ones(1, N))))
            Xb = X + Noise
    Sigma_x[:, :, 1, 1] = dot(Sigma_b, O)
    Sigma_x[:, :, 1, 2] = 0
    Sigma_x[:, :, 2, 1] = 0
    Sigma_x[:, :, 2, 2] = dot(Sigma_b, O)
    for j in arange(1, J).reshape(-1):
        Sigma_x[:, :, 1, 1] = Sigma_x[:, :, 1, 1] + \
            multiply((dot(abs(A[:, 1, j]) ** 2, O)), sigma_ss[:, :, j])
        Sigma_x[:, :, 1, 2] = Sigma_x[:, :, 1, 2] + \
            multiply(
                (dot((multiply(A[:, 1, j], conj(A[:, 2, j]))), O)), sigma_ss[:, :, j])
        Sigma_x[:, :, 2, 1] = conj(Sigma_x[:, :, 1, 2])
        Sigma_x[:, :, 2, 2] = Sigma_x[:, :, 2, 2] + \
            multiply((dot(abs(A[:, 2, j]) ** 2, O)), sigma_ss[:, :, j])
    Det_Sigma_x = multiply(
        Sigma_x[:, :, 1, 1], Sigma_x[:, :, 2, 2]) - abs(Sigma_x[:, :, 1, 2]) ** 2
    Inv_Sigma_x[:, :, 1, 1] = Sigma_x[:, :, 2, 2] / Det_Sigma_x
    Inv_Sigma_x[:, :, 1, 2] = - Sigma_x[:, :, 1, 2] / Det_Sigma_x
    Inv_Sigma_x[:, :, 2, 1] = conj(Inv_Sigma_x[:, :, 1, 2])
    Inv_Sigma_x[:, :, 2, 2] = Sigma_x[:, :, 1, 1] / Det_Sigma_x
    log_like = - sum(sum(log(dot(Det_Sigma_x, pi)) + multiply(Inv_Sigma_x[:, :, 1, 1], (abs(Xb[:, :, 1]) ** 2)) + multiply(Inv_Sigma_x[:, :, 2, 2], (abs(
        Xb[:, :, 2]) ** 2)) + dot(2, real(multiply(multiply(Inv_Sigma_x[:, :, 1, 2], conj(Xb[:, :, 1])), Xb[:, :, 2]))))) / (dot(N, F))
    if iter > 1:
        log_like_diff = log_like - log_like_arr[iter - 1]
        fprintf('Log-likelihood: %f   Log-likelihood improvement: %f\\n',
                log_like, log_like_diff)
    else:
        fprintf('Log-likelihood: %f\\n', log_like)
    log_like_arr[iter] = log_like
    for j in arange(1, J).reshape(-1):
        # compute S-Wiener gain
        Gs[:, :, j, 1] = multiply((multiply((dot(conj(A[:, 1, j]), O)), Inv_Sigma_x[:, :, 1, 1]) + multiply(
            (dot(conj(A[:, 2, j]), O)), Inv_Sigma_x[:, :, 2, 1])), sigma_ss[:, :, j])
        Gs[:, :, j, 2] = multiply((multiply((dot(conj(A[:, 1, j]), O)), Inv_Sigma_x[:, :, 1, 2]) + multiply(
            (dot(conj(A[:, 2, j]), O)), Inv_Sigma_x[:, :, 2, 2])), sigma_ss[:, :, j])
        Gs_x[:, :, j] = multiply(
            Gs[:, :, j, 1], Xb[:, :, 1]) + multiply(Gs[:, :, j, 2], Xb[:, :, 2])
        bar_Rxs[:, 1, j] = mean(
            multiply(Xb[:, :, 1], conj(Gs_x[:, :, j])), 2)
        bar_Rxs[:, 2, j] = mean(
            multiply(Xb[:, :, 2], conj(Gs_x[:, :, j])), 2)
    for j1 in arange(1, J).reshape(-1):
        # compute average Rss
        for j2 in arange(1, J).reshape(-1):
            bar_Rss[:, j1, j2] = mean(multiply(Gs_x[:, :, j1], conj(Gs_x[:, :, j2])) - multiply((multiply(
                Gs[:, :, j1, 1], (dot(A[:, 1, j2], O))) + multiply(Gs[:, :, j1, 2], (dot(A[:, 2, j2], O)))), sigma_ss[:, :, j2]), 2)
        bar_Rss[:, j1, j1] = bar_Rss[:, j1, j1] + \
            mean(sigma_ss[:, :, j1], 2)
    bar_Rxx[:, 1, 1] = mean(abs(Xb[:, :, 1]) ** 2, 2)
    bar_Rxx[:, 2, 2] = mean(abs(Xb[:, :, 2]) ** 2, 2)
    bar_Rxx[:, 1, 2] = mean(multiply(Xb[:, :, 1], conj(Xb[:, :, 2])), 2)
    bar_Rxx[:, 2, 1] = conj(bar_Rxx[:, 1, 2])
    for f in arange(1, F).reshape(-1):
        bar_Rss[f, :, :] = (squeeze(bar_Rss[f, :, :]) +
                            squeeze(bar_Rss[f, :, :]).T) / 2
    for j in arange(1, J).reshape(-1):
        for k in source_NMF_ind[j].reshape(-1):
            bar_A[:, :, k] = A[:, :, j]
    for k in arange(1, K).reshape(-1):
        # compute a priori component variances
        sigma_cc_k = dot(W[:, k], H[k, :])
        Gc_k_1 = multiply((multiply((dot(conj(bar_A[:, 1, k]), O)), Inv_Sigma_x[:, :, 1, 1]) + multiply(
            (dot(conj(bar_A[:, 2, k]), O)), Inv_Sigma_x[:, :, 2, 1])), sigma_cc_k)
        Gc_k_2 = multiply((multiply((dot(conj(bar_A[:, 1, k]), O)), Inv_Sigma_x[:, :, 1, 2]) + multiply(
            (dot(conj(bar_A[:, 2, k]), O)), Inv_Sigma_x[:, :, 2, 2])), sigma_cc_k)
        Gc_x_k = multiply(Gc_k_1, Xb[:, :, 1]) + \
            multiply(Gc_k_2, Xb[:, :, 2])
        # IT IS IMPORTANT TO TAKE A REAL PART !!!!
        Vc[:, :, k] = abs(Gc_x_k) ** 2 + sigma_cc_k - multiply(real(multiply(Gc_k_1, (dot(
            bar_A[:, 1, k], O))) + multiply(Gc_k_2, (dot(bar_A[:, 2, k], O)))), sigma_cc_k)
    fprintf('   M-step\\n')
    for f in arange(1, F).reshape(-1):
        A[f, :, :] = dot(squeeze(mean(bar_Rxs[f, :, :], 1)),
                         inv(squeeze(mean(bar_Rss[f, :, :], 1))))
    if Sigma_b_Upd_flag:
        for f in arange(1, F).reshape(-1):
            Sigma_b[f] = dot(0.5, real(trace(squeeze(bar_Rxx[f, :, :]) - dot(squeeze(A[f, :, :]), squeeze(bar_Rxs[f, :, :]).T) - dot(squeeze(
                bar_Rxs[f, :, :]), squeeze(A[f, :, :]).T) + dot(dot(squeeze(A[f, :, :]), squeeze(bar_Rss[f, :, :])), squeeze(A[f, :, :]).T))))
    for k in arange(1, K).reshape(-1):
        W[:, k] = sum(Vc[:, :, k] / (dot(ones(F, 1), H[k, :])), 2) / N
        H[k, :] = sum(Vc[:, :, k] / (dot(W[:, k], ones(1, N))), 1) / F
    for j in arange(1, J).reshape(-1):
        nonzero_f_ind = find(A[:, 1, j] != 0)
        A[nonzero_f_ind, 2, j] = A[nonzero_f_ind, 2, j] / \
            sign(A[nonzero_f_ind, 1, j])
        A[nonzero_f_ind, 1, j] = A[nonzero_f_ind, 1, j] / \
            sign(A[nonzero_f_ind, 1, j])
        A_scale = abs(A[:, 1, j]) ** 2 + abs(A[:, 2, j]) ** 2
        A[:, :, j] = A[:, :, j] / (dot(sqrt(A_scale), cat(1, 1)))
        W[:, source_NMF_ind[j]] = multiply(
            W[:, source_NMF_ind[j]], (dot(A_scale, ones(1, length(source_NMF_ind[j])))))
    w = sum(W, 1)
    d = diag(ones(1, K) / w)
    W = dot(W, d)
    d = diag(w)
    H = dot(d, H)

# source estimates
S = copy(Gs_x)
# return parameters estimated on previous iteration, since they were used
# for source estimates computation
W = copy(W_prev)
H = copy(H_prev)
A = copy(A_prev)
Sigma_b = copy(Sigma_b_prev)
